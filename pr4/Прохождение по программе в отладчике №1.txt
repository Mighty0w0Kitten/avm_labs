-При запуске программа инициализирует память: переменная sum (2 байта) 
обнуляется, флаг digit_flag обнуляется, а в шестой ячейке буфера sum_str 
сразу записывается символ '\n' (код 10).

-Далее начинается цикл read_loop, в котором макрос Getchar считывает по 
одному байту из stdin.

После каждого чтения программа:
    1)Сохраняет полученный байт в регистр AL.
    2)Сравнивает его с '\n'. Если это перевод строки, ветка handle_newline 
    проверяет, был ли ранее найден цифровой символ в этой строке 
    (digit_flag=1). Если был, сумма sum (регистр AX) увеличивается на 
    значение последней цифры (CX), и проверяется флаг переноса CF: только 
    при переполнении происходит переход в ветку overflow.
    4)Если байт не '\n', проверяется, является ли он символом '0'..'9'. Для 
    цифры программа преобразует ASCII‑код в число (вычитает '0'), 
    записывает его в last_digit и ставит digit_flag=1 .

Берём для примера строки "8" , "6" , "4":
-При чтении '8' AL становится 56 ('8'), затем вычитание '0' даёт AL=8, эта 
цифра записывается в last_digit, digit_flag=1.
-При чтении '\n' в конце первой строки digit_flag=1, поэтому 
сумма sum (AX) обновляется: 0 + 8 = 8, флаг переноса CF остаётся 0 
(нет переполнения).
-При чтении '6' аналогично AL=54, затем AL=6, last_digit=6, digit_flag=1; 
после '\n' сумма становится 8+6=14, CF=0.
-Для '4'→AL=4, last_digit=4; после '\n' сумма 14+4=18, CF=0.
После каждой обработки '\n' digit_flag сбрасывается, чтобы предыдущая 
цифра не влияла на следующую строку

Когда макрос Getchar возвращает 0 (EOF), выполняется ветка end_of_file. 
Программа загружает накопленное значение sum в регистр EAX и начинает 
делить его на 10, сохраняя остатки (цифры) в буфере sum_str слева направо.
Деление осуществляется в цикле:
-Перед каждой инструкцией divl $10 регистр EDX обнуляется; после деления 
в EAX остаётся частное, в EDX — остаток (очередная цифра).
-Остаток 0..9 переводится в ASCII‑код добавлением '0' и записывается 
в буфер на позицию левее.
-Цикл повторяется, пока частное не станет 0.

В вашем случае sum=18: первая итерация делит 18 на 10, даёт частное 1 и 
остаток 8 (в буфер пишется '8'); вторая делит 1 на 10 — частное 0, 
остаток 1 (пишется '1'). Получается строка "18\n". Длина вычисляется 
как (sum_str+6) − EDI, что даёт 3 байта для вывода (две цифры и перевод 
строки). Затем системный вызов write выводит эти байты на экран и 
программа завершается.

Итак, для входа "8", "6", "4" регистр AX принимает 
значения 0 → 8 → 14 → 18, флаг переноса CF остаётся равным 0, так как 
сумма не превышает 65535. После деления сумма преобразуется в 
строку "18\n", которая выводится через write, и программа выходит 
через Exit.
