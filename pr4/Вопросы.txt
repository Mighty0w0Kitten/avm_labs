"overflow_len = . - overflow_msg # на этапе ассемблирования вычисляется 
длина строки overflow_msg" Зачем это нужно?

В Linux‑системных вызовах, которые вы используете, функция `write` 
принимает три аргумента: файловый дескриптор, адрес данных и 
количество байтов, которое нужно отправить. 
Сам ассемблер не знает длину строки «Переполнение\n» — он просто 
размещает её в памяти. Поэтому мы вводим символическую константу:

overflow_len = . - overflow_msg

Здесь `.` обозначает текущую позицию ассемблера; 
вычитая адрес начала строки (`overflow_msg`), мы получаем её фактическую 
длину. Эта константа подставляется в поле `EDX` при вызове `write` — и 
тогда выводится ровно столько символов, сколько содержит сообщение. 
Если бы вы использовали макрос `Puts`, вычислять длину не требовалось бы, 
потому что макрос формирует строку сам. Но при прямом вызове `write` 
без правильного значения в `EDX` можно было бы вывести лишние байты или, 
наоборот, не вывести весь текст.

-------------------------------------------------------------------------

Что значит ".ascii" ?

Директива `.ascii` — это команда ассемблера GNU (GAS), которая помещает 
прямо в объектный файл набор байтов, соответствующих указанной строке 
в ASCII‑кодировке. Например, строка

overflow_msg:
    .ascii "Переполнение\n"

создаёт в секции `.data` последовательность байтов, равную ASCII‑кодам 
символов «П», «е», «р» … и символа перевода строки `\n`. В отличие от 
директивы `.string` (или эквивалентной `.asciz`), `.ascii` не
добавляет завершающий нулевой байт (`\0`) в конец, поэтому вы сами 
контролируете, что именно будет записано в память. Эта директива удобна 
для хранения текстовых сообщений, которые затем передаются в системный 
вызов `write`, как в нашем примере.

-------------------------------------------------------------------------

"буфер для хранения прочитанного байта из stdin" тоже самое 
что "буфер для хранения прочитанного байта из строки" ?

В нашем контексте это немного разные вещи. Переменная `c` используется 
как ячейка памяти, куда макрос `Getchar` записывает **один байт, 
прочитанный из стандартного ввода** (`stdin`), то есть из потока данных, 
которым обычно является клавиатура или перенаправлённый файл. Поэтому в 
комментарии и говорится «буфер для хранения прочитанного байта из 
stdin» — подчёркивается источник данных (файловый дескриптор 0).
Если бы мы работали со строкой, уже размещённой в памяти нашей программы, 
нам не потребовался бы системный вызов `read`: мы бы просто обращались к 
элементам этого массива. В таком случае комментарий «буфер для хранения 
прочитанного байта из строки» означал бы совсем другое — временное 
хранение символа, взятого из уже существующей строки. В данном же примере 
буфер `c` служит для приёма байтов, которые поступают из стандартного 
потока ввода.

-------------------------------------------------------------------------

".lcomm sum_str, 7 # буфер вывода: максимум 5 цифр, затем '\n', плюс 
запас под '\0' (не используется)" 
Зачем нам по итогу нужно такое условие?

Всё дело в том, чтобы заранее зарезервировать достаточно места для всех 
возможных символов, которые нужно вывести, и при этом упростить адресные 
вычисления.
Для 16‑битного беззнакового числа максимальное десятичное представление 
— «65535», то есть пять цифр. К ним мы добавляем символ перевода строки, 
чтобы после числа курсор перешёл на новую строку. Это уже шесть байтов. 
В нашем коде мы вычисляем адрес первого байта после строки 
как `sum_str+6` и используем его для расчёта длины:

leal sum_str+6, %esi   # адрес одного байта за '\n'
subl %edi, %esi        # длина = (&sum_str[6] - EDI)

Если бы буфер был размером ровно 6 байт, адрес `sum_str+6` указывал бы 
на память за пределами выделенной области, что само по себе неопасно 
в этом примере, но нарушает аккуратность и может путать. Чтобы избежать 
таких пограничных ситуаций, часто резервируют на один байт больше: это 
даёт «запас» как для безопасной адресной арифметики, так и для 
потенциального нулевого терминирующего символа (`'\0'`), если бы вы 
захотели превратить строку в C‑style.
Таким образом, `.lcomm sum_str, 7` — это просто аккуратная заготовка: пять 
цифр + перевод строки + ещё один свободный байт. В самом выводе мы 
используем только шесть символов (цифры и `\n`), а нулевой байт нам не 
нужен, потому что мы выводим строку через системный вызов `write` и 
передаём длину явно.

-------------------------------------------------------------------------

Что значит ".lcomm" ?

Директива .lcomm (сокращение от local common) используется в 
GNU Assembler для выделения блока неинициализированной памяти в 
секции .bss. Запись вида

.lcomm имя, размер

означает «создать символ имя и зарезервировать под него указанное 
количество байтов, не инициализируя их». В отличие от .comm, такой 
символ имеет локальную область видимости (не экспортируется как 
глобальный), а выделенный участок памяти будет обнулён загрузчиком при 
запуске программы.
В нашем примере строки вроде .lcomm sum_str, 7 или .lcomm c, 1 создают 
переменные sum_str, c и другие в секции .bss и резервируют 
соответствующее количество байтов для хранения данных, которые будут 
использоваться во время работы программы.

-------------------------------------------------------------------------

Что значит "беззнаковое сложение" ?

В двоичном коде одна и та же последовательность битов может трактоваться 
по‑разному: либо как знакoвое число (где старший бит отвечает за знак), 
либо как беззнаковое, то есть неотрицательное. Термин «беззнаковое 
сложение» означает, что при выполнении операции мы считаем оба операнда 
и результат целыми числами без знака — диапазон для 16‑битного случая 
от 0 до 65535.
Практически это влияет на то, как определять переполнение. 
В unsigned‑арифметике нас интересует, была ли потеряна единичка при 
переносе из старшего бита: процессор устанавливает флаг переноса (CF), 
если сумма не помещается в отведённую разрядную сетку. Поэтому в нашем 
коде после addw %cx, %ax проверяется именно jc overflow — проверка 
carry‑flag для беззнакового переполнения. В signed‑арифметике, наоборот, 
анализируют флаг переполнения (OF), который показывает, вышел ли 
результат за диапазон знаковых чисел (например, от −32768 до 32767 для 
16‑бит).

-------------------------------------------------------------------------

Зачем мы в конечном итоге делаем это: "movb $10, sum_str+5" ?

заносит в шестой байт буфера sum_str значение 10 — это ASCII‑код 
символа перевода строки '\n'. Мы делаем это заранее по двум причинам:
1-Фиксированная позиция конца строки. Максимальное десятичное 
представление 16‑битного числа содержит пять цифр (0 … 65535). 
Буфер sum_str зарезервирован на семь байтов, и ячейки с индексами 0–4 
будут заполняться цифрами справа налево. Позиция 5 (sum_str+5) выступает 
как фиксированный разделитель: там сразу лежит символ '\n', а символ 
sum_str+6 остаётся «один байт за строкой» для удобства вычисления длины. 
Это позволяет нам при построении строки просто двигать указатель EDI 
влево и, не думая о добавлении конца строки, записывать цифры перед уже 
готовым переводом строки.
2-Корректный вывод. Когда программа выводит результат через системный 
вызов write, она отправляет сразу число и символ перевода строки. 
Благодаря тому, что '\n' уже находится в буфере, пользователю не нужно 
вручную нажимать Enter после вывода — курсор автоматически переходит на 
новую строку.
В итоге эта строчка упрощает логику преобразования числа в текст: цифры 
записываются слева от заранее подготовленного '\n', и потом одной 
операцией выводится «число + перевод строки»

-------------------------------------------------------------------------

Перевод в 10, 8 и 2 системы

По сути это тоже самое что и вывод числа в 10-й системе, только в тех 
циклах мы делим их по другому?
Различия касаются только:
-- Делителя: для десятичной системы это 10, для 
восьмеричной — 8, для двоичной — 2.
-- Размеров буфера и позиции \n: у 16‑битного числа максимум 5 десятичных, 6 восьмеричных 
или 16 двоичных цифр, поэтому в .bss выделены разные по длине буферы, а в начале 
программы в них заранее помещается символ '\n' на соответствующую позицию.
-- Расчёта длины: после записи цифр в буфер длина строки получается как разность 
«конец – текущий указатель» (например, (oct_str+7) - EDI).
В остальном алгоритм этих циклов полностью аналогичен десятичному: divl выполняет деление, 
в EDX остаётся остаток, который плюс '0' превращается в ASCII‑символ и сохраняется в 
буфер; указатель сдвигается влево на позицию для следующей цифры; когда частное становится 
нулём, цикл завершается и вызывается write для вывода готовой строки.


