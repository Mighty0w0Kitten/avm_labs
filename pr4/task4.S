/*
 * task4.S — суммирование последних цифр строк.
 * Программа читает символы из стандартного ввода построчно.
 * Для каждой строки она запоминает последнюю встреченную цифру (0–9), стоящую перед символом перевода строки '\n'.
 * Эти цифры накапливаются в 16‑битной беззнаковой сумме. После каждой операции сложения проверяется флаг переноса (carry):
 * если происходит переполнение диапазона 0..65535, выводится сообщение «Переполнение» и программа завершается.
 * Когда ввод заканчивается (EOF), накопленное значение переводится в десятичную строку и выводится на экран с переводом строки.
 */

    .include "my-macro"            # подключаем макросы для Exit, Getchar, Puts

    # -------------------------------
    # Секция инициализированных данных
    # -------------------------------
    .data
overflow_msg:
    .ascii "Переполнение\n"        # текст сообщения, если сумма выходит за 16‑битный диапазон
overflow_len = . - overflow_msg    # на этапе ассемблирования вычисляется длина строки overflow_msg

    # -------------------------------
    # Секция неинициализированных данных (.bss)
    # Здесь мы резервируем память, но не задаём значения. При запуске они обнуляются.
    # -------------------------------
    .bss
        .lcomm c, 1                # буфер для хранения прочитанного байта из stdin
        .lcomm last_digit, 1       # хранит числовое значение последней найденной цифры (0..9)
        .lcomm digit_flag, 1       # флаг: 1 — last_digit содержит актуальное значение, 0 — нет цифры в текущей строке
        .lcomm sum, 2              # 16‑битный аккумулятор для суммы (0..65535)
        .lcomm sum_str, 7          # буфер вывода: максимум 5 цифр, затем '\n', плюс запас под '\0' (не используется)

    # -------------------------------
    # Секция кода
    # -------------------------------
    .text
    .global _start

_start:
        # ---- Инициализация переменных ----
        movw $0, sum               # обнуляем 2‑байтовую переменную sum (сложение будет беззнаковым)
        movb $0, digit_flag        # пока ни одной цифры не встретили

        # подготовим буфер вывода: поместим символ '\n' (код 10) в фиксированную позицию
        # далее при построении строки цифры будут помещаться левее этого символа
        movb $10, sum_str+5        # sum_str[5] = '\n' (ASCII 10)

read_loop:
        # ---- Чтение следующего символа ----
        # макрос Getchar читает 1 байт из stdin (дескриптор 0) в буфер c
        # по завершении макроса в %eax возвращается количество считанных байтов: 0 => EOF, 1 => прочитан байт
        Getchar $c
        cmpl $0, %eax
        je end_of_file             # если ничего не прочитано (EOF), прерываем цикл

        # загружаем символ из буфера c в %al для анализа
        movb c, %al

        # ---- Проверка на символ новой строки ----
        # если встречаем '\n', нужно обработать накопленную последнюю цифру (если была)
        cmpb $10, %al              # 10 — это ASCII-код '\n'
        je handle_newline

        # ---- Проверка, является ли символ цифрой '0'..'9' ----
        # игнорируем любые символы меньше '0'
        cmpb $'0', %al
        jb read_loop
        # игнорируем символы больше '9'
        cmpb $'9', %al
        ja read_loop

        # ---- Символ — цифра ----
        # преобразуем ASCII-код в числовое значение 0..9 путём вычитания кода '0'
        subb $'0', %al
        movb %al, last_digit       # запоминаем значение цифры
        movb $1, digit_flag        # ставим флаг, что в текущей строке есть цифра
        jmp read_loop              # читаем следующий символ

handle_newline:
        # ---- Обработка конца строки ----
        # если цифра была найдена до '\n', добавляем её к сумме
        cmpb $0, digit_flag
        je reset_digit_flag        # если флаг сброшен, цифры не было — ничего не добавляем

        # загружаем текущую 16‑битную сумму в регистр EAX (zero extend)
        movzwl sum, %eax           # EAX = sum (расширяем 2 байта до 32‑бит)
        # загружаем последнюю цифру в ECX (zero extend до 32‑бит)
        movzbl last_digit, %ecx    # ECX = last_digit
        # прибавляем ECX к AX (16‑битное сложение) и проверяем флаг переноса
        addw %cx, %ax              # AX = AX + CX; CF = 1 при переполнении диапазона 16‑бит
        jc overflow                # если CF=1, то сумма > 65535 — переполнение
        # сохраняем обновлённую сумму обратно в память
        movw %ax, sum

reset_digit_flag:
        # сбрасываем флаг наличия цифры для следующей строки
        movb $0, digit_flag
        jmp read_loop

overflow:
        # ---- Вывод сообщения о переполнении и завершение ----
        movl $4, %eax              # номер системного вызова write
        movl $1, %ebx              # дескриптор 1 (stdout)
        movl $overflow_msg, %ecx   # адрес строки сообщения
        movl $overflow_len, %edx   # длина строки сообщения
        int $0x80                  # выполняем системный вызов write(stdout, msg, len)
        Exit $0                    # завершаем программу (код возврата 0)

end_of_file:
        # ---- Конец ввода: преобразуем сумму в десятичную строку ----
        # загружаем суммарное 16‑битное значение в EAX
        movzwl sum, %eax           # EAX = sum (без знака)
        # EDI будет указывать на позицию '\n' в буфере sum_str
        leal sum_str+5, %edi

convert_loop:
        # если EAX != 0, делим на 10 и получаем очередную цифру
        xorl %edx, %edx            # обнуляем EDX для правильного деления 64‑битного EDX:EAX
        movl $10, %ebx             # делитель = 10
        divl %ebx                  # беззнаковое деление: (EDX:EAX)/EBX => EAX=частное, EDX=остаток
        decl %edi                  # освобождаем позицию слева от '\n' для записи цифры
        addb $'0', %dl             # преобразуем остаток 0..9 в ASCII-символ
        movb %dl, (%edi)           # сохраняем ASCII-цифру по адресу %edi
        testl %eax, %eax           # проверяем, стало ли частное нулём?
        jne convert_loop           # если нет, продолжаем извлекать цифры

        # ---- Вычисляем длину получившейся строки ----
        # sum_str+6 указывает на первый байт ПОСЛЕ '\n'.
        # (sum_str+6) - EDI = количество байтов, которые нужно вывести (цифры + '\n').
        leal sum_str+6, %esi       # ESI = &sum_str[6]
        subl %edi, %esi            # ESI = длина = (&sum_str[6] - EDI)
        movl %esi, %edx            # EDX = длина для системного вызова write
        movl %edi, %ecx            # ECX = адрес первой цифры для вывода

        # ---- Печатаем строку (цифры и '\n') ----
        movl $4, %eax              # write syscall
        movl $1, %ebx              # дескриптор stdout
        int $0x80                  # write(1, ecx, edx)

        Exit $0                    # завершаем программу

