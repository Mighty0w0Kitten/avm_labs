/*
* task4.S — суммирование последних цифр строк (С УЧЁТОМ ЗНАКА)
* Программа читает символы из стандартного ввода построчно.
* Для каждой строки она запоминает последнюю встреченную цифру (0–9), стоящую перед символом перевода строки '\n'.
* Знак числа определяется наличием символа '-' перед этой цифрой.
* Эти значения накапливаются в 16‑битной СИГНОВОЙ сумме (диапазон −32768..32767).
* После каждой операции сложения проверяется флаг знакового переполнения (OF):
* при OF=1 выводится сообщение «Переполнение» и программа завершается.
* Когда ввод заканчивается (EOF), итоговое значение печатается в десятичной, восьмеричной и двоичной системах
* счисления с учётом знака: при отрицательном значении сначала выводится '-', затем абсолютная величина.
*/


    .include "my-macro"            # подключаем макросы для Exit, Getchar, Puts

    # -------------------------------
    # Секция инициализированных данных
    # -------------------------------
    .data
overflow_msg:
    .ascii "Переполнение\n"        # текст сообщения, если сумма выходит за 16‑битный диапазон
overflow_len = . - overflow_msg    # на этапе ассемблирования вычисляется длина строки overflow_msg

sign_char:
    .ascii "-"         # символ минуса для вывода отрицательных чисел
sign_len = . - sign_char

    # -------------------------------
    # Секция неинициализированных данных (.bss)
    # Здесь мы резервируем память, но не задаём значения. При запуске они обнуляются.
    # -------------------------------
    .bss
        .lcomm c, 1                # Буфер (1 байт) под очередной символ из stdin
        .lcomm last_digit, 1       # последняя найденная цифра со знаком (−9..9)
        .lcomm digit_flag, 1       # флаг: 1 — цифра в текущей строке была, 0 — не была
        .lcomm sum, 2              # 16‑битная ЗНАКОВАЯ сумма (−32768..32767)
        .lcomm sum_str, 7          # Десятичный буфер: до 5 цифр + '\n' + запас
        .lcomm oct_str, 8          # Восьмеричный буфер: (до 6 цифр + '\n' + запас)
        .lcomm bin_str, 18         # Двоичный буфер: (до 16 цифр + '\n' + запас)
        .lcomm neg_flag, 1         # флаг отрицательного числа: перед цифрой встретился '-' (1) или нет (0)

    # -------------------------------
    # СЕКЦИЯ .text — КОД ПРОГРАММЫ
    # -------------------------------
    .text
    .global _start

_start:
        # ---- Инициализация переменных ----
        movw $0, sum               # обнуляем 16‑битную сумму (дальше работаем как со знаковой)
        movb $0, digit_flag        # в текущей строке цифры ещё не было
        movb $0, neg_flag          # пока не встретили '-' (сброс флага отрицательного числа)
        # подготовим буферы: заранее положим '\n' в фиксированные позиции
        movb $10, sum_str+5        # sum_str[5] = '\n' (ASCII 10)
        movb $10, oct_str+6        # восьмеричное: максимум 6 цифр, индекс 6 — '\n' (oct_str[6] = '\n')
        movb $10, bin_str+16       # двоичное: максимум 16 цифр, индекс 16 — '\n' (bin_str[16] = '\n')

read_loop:
        # Шаг 1. Прочитать один символ из стандартного ввода (клавиатура или файл).
        # Getchar $c кладёт символ в переменную c.
        # В EAX: 1 — символ есть; 0 — конец файла.
        # Возвращает в EAX число прочитанных байтов: 1 — успех, 0 — EOF.
        Getchar $c
        cmpl $0, %eax              # если 0, больше читать нечего
        je end_of_file             # EAX==0 → конец файла → выходим из общего цикла

        # Шаг 2. Взять этот символ в AL, чтобы удобно сравнивать.
        movb c, %al

        # Шаг 3. Если символ — перевод строки встречает '\n' значит строка закончилась.
        cmpb $10, %al              # 10 — код '\n'
        je handle_newline          

        # Шаг 4. Если это '-' — запоминаем, что СЛЕДУЮЩАЯ цифра будет со знаком минус.
        # Сам минус не складываем.
        cmpb $'-', %al        # <── добавлено: проверяем, встречен ли символ '-'
        je set_negative        # если да — перейти к установке флага neg_flag


        # Шаг 5. ---- Проверка, является ли символ цифрой '0'..'9' ----
        # игнорируем любые символы меньше '0'
        cmpb $'0', %al
        jb read_loop
        # игнорируем символы больше '9'
        cmpb $'9', %al
        ja read_loop

        # Шаг 6. ---- Символ — цифра.----
        # преобразуем ASCII-код в числовое значение 0..9 путём вычитания кода '0'
        subb $'0', %al
        # Шаг 7. Если перед цифрой стоял '-', делаем число отрицательным.
        # Флаг neg_flag действует только на одну ближайшую цифру, затем сбрасывается.
        cmpb $0, neg_flag          # если перед цифрой был '-', инвертируем знак
        je store_digit
        negb %al                   # делаем цифру отрицательной
        movb $0, neg_flag          # знак израсходовали
store_digit:
        # Шаг 8. Запомнить эту (возможную отрицательную) цифру и отметить, что в этой строке цифра есть.
        movb %al, last_digit       # запоминаем значение цифры
        movb $1, digit_flag        # ставим флаг, что в текущей строке есть цифра
        jmp read_loop              # читаем следующий символ

set_negative:                      # обработчик знака '-'
        movb $1, neg_flag          # запомним, что следующая цифра со знаком '-'
        jmp read_loop

handle_newline:
        # ---- Обработка конца строки ----
        # если цифра была найдена до '\n', добавляем её к сумме
        cmpb $0, digit_flag
        je reset_digit_flag        # если флаг сброшен, цифры не было — ничего не добавляем

        # загружаем текущую сумму С ЗНАКОМ (sign‑extend 16->32)
        movswl sum, %eax           # EAX = sum (расширяем 2 байта до 32‑бит)
        # загружаем последнюю цифру С ЗНАКОМ (sign‑extend 8->32)
        movsbl last_digit, %ecx    # ECX = last_digit
        # складываем как знаковые 16‑битные: AX += CX; флаг OF сигнализирует ЗНАКОВОЕ переполнение
        addw %cx, %ax              
        jo overflow                # OF=1 → вышли за −32768..32767
        movw %ax, sum              # сохраняем обновлённую сумму

reset_digit_flag:
        movb $0, digit_flag        # сбрасываем флаг наличия цифры для следующей строки
        movb $0, neg_flag          # сбрасываем возможный «висящий» знак строки
        jmp read_loop

overflow:
        # ---- Вывод сообщения о переполнении и завершение ----
        movl $4, %eax              # номер системного вызова: sys_write = 4
        movl $1, %ebx              # файловый дескриптор: 1 = stdout
        movl $overflow_msg, %ecx   # адрес строки сообщения "Переполнение\n"
        movl $overflow_len, %edx   # длина строки сообщения
        int $0x80                  # выполняем системный вызов write(stdout, msg, len)
        Exit $0                    # завершаем программу (код возврата 0)

end_of_file:
        # === Конец ввода. Печать результата в 10, 8 и 2‑й системах ===
        # Общая идея: учитываем знак, печатаем '-' при необходимости,
        # затем переводим абсолютное значение в нужную систему и выводим цифры + "\n"
        
        # ---- Десятичный вывод (с учётом знака) ----
        movswl  sum, %eax          # EAX = сумма со знаком (переносим 16 бит → 32 бита с сохранением знака)
        movl %eax, %esi            # Сохраняем исходное значение (со знаком) для последующих форматов (8 и 2)
        testl %eax, %eax           # Проверяем знак: < 0 ?
        jge dec_no_sign            # Если число неотрицательное, '-' не печатаем
        negl %eax                  # Делаем модуль числа (абсолютное значение) для последующей печати
        movl $1, %ebx              # fd=1 (stdout) для write
        movl $4, %eax              # sys_write: Linux x86 int $0x80, номер 4 (write)
        movl $sign_char, %ecx      # Адрес строки "-"
        movl $sign_len, %edx       # Длина строки "-" (1)
        int $0x80                  # write(1, "-", 1)
dec_no_sign:
        # Подготавливаем буфер: будем писать цифры справа налево, перед заранее положенным "\n"
        leal sum_str+5, %edi       # EDI указывает на байт с "\n" в sum_str
        movl $10, %ebx             # Делитель = 10

        # Цикл: делим число на 10, остаток превращаем в символ, пишем влево, повторяем пока частное != 0

dec_convert_loop:
        # если EAX != 0, делим на 10 и получаем очередную цифру
        xorl %edx, %edx            # обнуляем EDX для правильного деления 64‑битного EDX:EAX
        divl %ebx                  # беззнаковое деление: (EDX:EAX)/EBX => EAX=частное, EDX=остаток
        decl %edi                  # Сдвигаем позицию в буфере влево под новую цифру
        addb $'0', %dl             # преобразуем остаток 0..9 в ASCII-символ (0..9 → ASCII '0'..'9')
        movb %dl, (%edi)           # Записываем символ цифры в буфер
        testl %eax, %eax           # проверяем, стало ли частное нулём?
        jne dec_convert_loop       # если нет, продолжаем извлекать цифры

        # Посчитать длину готовой строки: (адрес после '\n') - (адрес первой цифры)
        # sum_str+6 указывает на первый байт ПОСЛЕ '\n'.
        # (sum_str+6) - EDI = количество байтов, которые нужно вывести (цифры + '\n').
        leal sum_str+6, %ecx       # ECX = адрес байта сразу после '\n' (это конец подстроки для вывода)
        subl %edi, %ecx            # ECX = длина (число символов цифр + один '\n')
        movl %ecx, %edx            # EDX = длина для системного вызова write
        movl %edi, %ecx            # ECX = адрес первой цифры для вывода write

        # ---- Печатаем десятичную строку (цифры + '\n') ----
        movl $4, %eax              # sys_write: Linux x86 int $0x80, номер 4 (write)
        movl $1, %ebx              # файловый дескриптор 1 = stdout
        int $0x80                  # write(1, ecx, edx)

        # --- Восьмеричное представление (с учётом знака) ---
        movl %esi, %eax            # EAX = исходная сумма со знаком
        testl %eax, %eax           # Проверка знака (EAX < 0?)
        jge oct_no_sign            # Если неотрицательно, знак не печатаем
        negl %eax                  # EAX = |EAX| для печати цифр
        movl $1, %ebx              # EBX=1? см. ниже: stdout (fd=1) для write
        movl $4, %eax              # EAX=4: sys_write (Linux int 0x80)
        movl $sign_char, %ecx      # ECX = адрес строки "-"
        movl $sign_len, %edx       # EDX = длина строки "-" (1)
        int $0x80                  # write(1, "-", 1)
oct_no_sign:
        leal oct_str+6, %edi       # EDI указывает на позицию '\n' в oct_str
        movl $8, %ebx              # EBX(делитель) = 8 (основание системы = 8)
oct_convert_loop:
        xorl %edx, %edx            # EDX = 0 перед divl (делим пару EDX:EAX)
        divl %ebx                  # (EDX:EAX)/8 → EAX=частное, EDX=остаток (0..7)
        decl %edi                  # Сдвиг указателя влево на позицию для новой цифры
        addb $'0', %dl             # Остаток 0..7 → символ '0'..'7'
        movb %dl, (%edi)           # Записать символ в буфер
        testl %eax, %eax           # Частное стало 0?
        jne oct_convert_loop       # Нет → продолжаем цикл
        
        leal oct_str+7, %ecx       # ECX = адрес байта после '\n' (конец подстроки)
        subl %edi, %ecx            # ECX = длина к выводу = (конец − начало)
        movl %ecx, %edx            # EDX = длина для write
        movl %edi, %ecx            # ECX = адрес начала цифр
        movl $4, %eax              # EAX=4: sys_write (Linux int 0x80)
        movl $1, %ebx              # EBX=1: stdout (fd=1)
        int $0x80                  # write(1, ECX, EDX)

        # --- Двоичное представление (с учётом знака) ---
        movl %esi, %eax            # EAX = исходная сумма со знаком
        testl %eax, %eax           # Проверка, отрицательно ли число
        jge bin_no_sign            # Если число неотрицательное, '-' не печатаем
        negl %eax                  # EAX = |EAX|, дальше печатаем модуль
        movl $1, %ebx              # sys_write: номер системного вызова (int 0x80)
        movl $4, %eax              # stdout: файловый дескриптор 1 (куда пишем)
        movl $sign_char, %ecx      # ECX = адрес строки "-"
        movl $sign_len, %edx       # EDX = длина строки "-" (1)
        int $0x80                  # вызвать write(1, "-", 1)
bin_no_sign:
        leal bin_str+16, %edi      # EDI указывает на '\n' в конце буфера; цифры пишем слева от него
        movl $2, %ebx              # EBX = 2, делитель = 2
bin_convert_loop:
        xorl %edx, %edx            # EDX = 0 перед divl (делим пару EDX:EAX)
        divl %ebx                  # (EDX:EAX)/2 → EAX=частное, EDX=остаток (0..1)
        decl %edi                  # сдвигаем позицию влево для следующего символа
        addb $'0', %dl             # остаток 0/1 превращаем в '0'/'1'
        movb %dl, (%edi)           # записываем символ в буфер
        testl %eax, %eax           # частное стало 0?
        jne bin_convert_loop       # нет — продолжаем
        
        leal bin_str+17, %ecx      # ECX = адрес байта сразу после '\n' (конец подстроки)
        subl %edi, %ecx            # ECX = длина к выводу = (конец − начало)
        movl %ecx, %edx            # EDX = длина для write
        movl %edi, %ecx            # ECX = адрес начала строки
        movl $4, %eax              # sys_write: номер вызова
        movl $1, %ebx              # stdout: fd=1
        int $0x80                  # write(1, ECX, EDX)


        Exit $0                    # код возврата 0; завершаем программу

