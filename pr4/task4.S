/*
 * task4.S — суммирование последних цифр строк.
 * Программа читает символы из стандартного ввода построчно.
 * Для каждой строки она запоминает последнюю встреченную цифру (0–9), стоящую перед символом перевода строки '\n'.
 * Эти цифры накапливаются в 16‑битной беззнаковой сумме. После каждой операции сложения проверяется флаг переноса (carry):
 * если происходит переполнение диапазона 0..65535, выводится сообщение «Переполнение» и программа завершается.
 * Когда ввод заканчивается (EOF), накопленное значение переводится в десятичную строку и выводится на экран с переводом строки.
 */

    .include "my-macro"            # подключаем макросы для Exit, Getchar, Puts

    # -------------------------------
    # Секция инициализированных данных
    # -------------------------------
    .data
overflow_msg:
    .ascii "Переполнение\n"        # текст сообщения, если сумма выходит за 16‑битный диапазон
overflow_len = . - overflow_msg    # на этапе ассемблирования вычисляется длина строки overflow_msg

sign_char:
    .ascii "-"         # символ минуса для вывода отрицательных чисел
sign_len = . - sign_char

    # -------------------------------
    # Секция неинициализированных данных (.bss)
    # Здесь мы резервируем память, но не задаём значения. При запуске они обнуляются.
    # -------------------------------
    .bss
        .lcomm c, 1                # буфер для хранения прочитанного байта из stdin
        .lcomm last_digit, 1       # хранит числовое значение последней найденной цифры (0..9)
        .lcomm digit_flag, 1       # флаг: 1 — last_digit содержит актуальное значение, 0 — нет цифры в текущей строке
        .lcomm sum, 2              # 16‑битный аккумулятор для суммы (0..65535)
        .lcomm sum_str, 7          # буфер вывода: максимум 5 цифр, затем '\n', плюс запас под '\0' (не используется)
        .lcomm oct_str, 8    # буфер для восьмеричного вида (до 6 цифр + '\n' + запас)
        .lcomm bin_str, 18   # буфер для двоичного вида (до 16 цифр + '\n' + запас)
        .lcomm neg_flag, 1    # флаг отрицательного числа: 1 — перед цифрой встретился '-', 0 — нет


    # -------------------------------
    # Секция кода
    # -------------------------------
    .text
    .global _start

_start:
        # ---- Инициализация переменных ----
        movw $0, sum               # обнуляем 2‑байтовую переменную sum (сложение будет беззнаковым)
        movb $0, digit_flag        # пока ни одной цифры не встретили
        movb $0, neg_flag          # NEW: сброс флага отрицательного числа
        # подготовим буфер вывода: поместим символ '\n' (код 10) в фиксированную позицию
        # далее при построении строки цифры будут помещаться левее этого символа
        movb $10, sum_str+5        # sum_str[5] = '\n' (ASCII 10)
        movb $10, oct_str+6    # восьмеричное: максимум 6 цифр, индекс 6 — '\n'
        movb $10, bin_str+16   # двоичное: максимум 16 цифр, индекс 16 — '\n'

read_loop:
        # ---- Чтение следующего символа ----
        # макрос Getchar читает 1 байт из stdin (дескриптор 0) в буфер c
        # по завершении макроса в %eax возвращается количество считанных байтов: 0 => EOF, 1 => прочитан байт
        Getchar $c
        cmpl $0, %eax
        je end_of_file             # если ничего не прочитано (EOF), прерываем цикл

        # загружаем символ из буфера c в %al для анализа
        movb c, %al

        # ---- Проверка на символ новой строки ----
        # если встречаем '\n', нужно обработать накопленную последнюю цифру (если была)
        cmpb $10, %al              # 10 — это ASCII-код '\n'
        je handle_newline

        cmpb $'-', %al        # <── добавлено: проверяем, встречен ли символ '-'
        je set_negative        # если да — перейти к установке флага neg_flag


        # ---- Проверка, является ли символ цифрой '0'..'9' ----
        # игнорируем любые символы меньше '0'
        cmpb $'0', %al
        jb read_loop
        # игнорируем символы больше '9'
        cmpb $'9', %al
        ja read_loop

        # ---- Символ — цифра ----
        # преобразуем ASCII-код в числовое значение 0..9 путём вычитания кода '0'
        subb $'0', %al
        cmpb $0, neg_flag          # если перед цифрой был '-', инвертируем знак
        je store_digit
        negb %al                   # делаем цифру отрицательной
        movb $0, neg_flag          # знак израсходовали
store_digit:
        movb %al, last_digit       # запоминаем значение цифры
        movb $1, digit_flag        # ставим флаг, что в текущей строке есть цифра
        jmp read_loop              # читаем следующий символ

set_negative:                      # обработчик знака '-'
        movb $1, neg_flag
        jmp read_loop

handle_newline:
        # ---- Обработка конца строки ----
        # если цифра была найдена до '\n', добавляем её к сумме
        cmpb $0, digit_flag
        je reset_digit_flag        # если флаг сброшен, цифры не было — ничего не добавляем

        # загружаем текущую 16‑битную сумму в регистр EAX (zero extend)
        movswl sum, %eax           # EAX = sum (расширяем 2 байта до 32‑бит)
        # загружаем последнюю цифру в ECX (zero extend до 32‑бит)
        movsbl last_digit, %ecx    # ECX = last_digit
        # прибавляем ECX к AX (16‑битное сложение) и проверяем флаг переноса
        addw %cx, %ax              # AX = AX + CX; CF = 1 при переполнении диапазона 16‑бит
        jo overflow                # если CF=1, то сумма > 65535 — переполнение
        # сохраняем обновлённую сумму обратно в память
        movw %ax, sum

reset_digit_flag:
        # сбрасываем флаг наличия цифры для следующей строки
        movb $0, digit_flag
        movb $0, neg_flag          # сбрасываем возможный «висящий» знак строки
        jmp read_loop

overflow:
        # ---- Вывод сообщения о переполнении и завершение ----
        movl $4, %eax              # номер системного вызова write
        movl $1, %ebx              # дескриптор 1 (stdout)
        movl $overflow_msg, %ecx   # адрес строки сообщения
        movl $overflow_len, %edx   # длина строки сообщения
        int $0x80                  # выполняем системный вызов write(stdout, msg, len)
        Exit $0                    # завершаем программу (код возврата 0)

end_of_file:
        # ---- Конец ввода: преобразуем сумму в десятичную строку (с учётом знака)----
        # загружаем суммарное 16‑битное значение в EAX
        movswl  sum, %eax           # EAX = sum ( сумма со знаком)
        movl %eax, %esi            # NEW: сохраним EAX для последующих форматов
        testl %eax, %eax
        jge dec_no_sign
        negl %eax                  # NEW: берём абсолютное значение
        movl $4, %ebx              # stdout
        movl $4, %eax              # write
        movl $sign_char, %ecx      # NEW: печатаем '-'
        movl $sign_len, %edx
        int $0x80
dec_no_sign:
        # EDI будет указывать на позицию '\n' в буфере sum_str
        leal sum_str+5, %edi
        movl $10, %ebx

dec_convert_loop:
        # если EAX != 0, делим на 10 и получаем очередную цифру
        xorl %edx, %edx            # обнуляем EDX для правильного деления 64‑битного EDX:EAX
        movl $10, %ebx             # делитель = 10
        divl %ebx                  # беззнаковое деление: (EDX:EAX)/EBX => EAX=частное, EDX=остаток
        decl %edi                  # освобождаем позицию слева от '\n' для записи цифры
        addb $'0', %dl             # преобразуем остаток 0..9 в ASCII-символ
        movb %dl, (%edi)           # сохраняем ASCII-цифру по адресу %edi
        testl %eax, %eax           # проверяем, стало ли частное нулём?
        jne dec_convert_loop           # если нет, продолжаем извлекать цифры

        # ---- Вычисляем длину получившейся строки ----
        # sum_str+6 указывает на первый байт ПОСЛЕ '\n'.
        # (sum_str+6) - EDI = количество байтов, которые нужно вывести (цифры + '\n').
        leal sum_str+6, %ecx       # ESI = &sum_str[6]
        subl %edi, %ecx            # ESI = длина = (&sum_str[6] - EDI)
        movl %ecx, %edx            # EDX = длина для системного вызова write
        movl %edi, %ecx            # ECX = адрес первой цифры для вывода

        # ---- Печатаем строку (цифры и '\n') ----
        movl $4, %eax              # write syscall
        movl $1, %ebx              # дескриптор stdout
        int $0x80                  # write(1, ecx, edx)

        # --- Восьмеричное представление (с учётом знака) ---
        movl %esi, %eax            # восстановим исходную сумму (со знаком)
        testl %eax, %eax
        jge oct_no_sign
        negl %eax                  # абсолют
        movl $4, %ebx
        movl $4, %eax
        movl $sign_char, %ecx      # печатаем '-'
        movl $sign_len, %edx
        int $0x80
oct_no_sign:
        leal oct_str+6, %edi       # EDI указывает на '\n' в oct_str
        movl $8, %ebx              # делитель = 8
oct_convert_loop:
        xorl %edx, %edx
        divl %ebx                  # делим EDX:EAX на 8; частное в EAX, остаток в EDX
        decl %edi                  # освобождаем позицию слева
        addb $'0', %dl             # остаток 0..7 -> ASCII
        movb %dl, (%edi)           # пишем цифру
        testl %eax, %eax
        jne oct_convert_loop
        leal oct_str+7, %ecx
        subl %edi, %ecx            # длина = (&oct_str[7] - EDI)
        movl %ecx, %edx
        movl %edi, %ecx
        movl $4, %eax
        movl $1, %ebx
        int $0x80                  # write(stdout, oct_str, длина)

        # --- Двоичное представление (с учётом знака) ---
        movl %esi, %eax            # снова исходная сумма (со знаком)
        testl %eax, %eax
        jge bin_no_sign
        negl %eax                  # абсолют
        movl $4, %ebx
        movl $4, %eax
        movl $sign_char, %ecx      # печатаем '-'
        movl $sign_len, %edx
        int $0x80
bin_no_sign:
        leal bin_str+16, %edi      # EDI указывает на '\n' в bin_str
        movl $2, %ebx              # делитель = 2
bin_convert_loop:
        xorl %edx, %edx
        divl %ebx                  # делим EDX:EAX на 2
        decl %edi
        addb $'0', %dl             # остаток 0..1 -> ASCII
        movb %dl, (%edi)
        testl %eax, %eax
        jne bin_convert_loop
        leal bin_str+17, %ecx
        subl %edi, %ecx            # длина = (&bin_str[17] - EDI)
        movl %ecx, %edx
        movl %edi, %ecx
        movl $4, %eax
        movl $1, %ebx
        int $0x80                  # write(stdout, bin_str, длина)



        Exit $0                    # завершаем программу

