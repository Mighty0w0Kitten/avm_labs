Прохождение по программе в отладчике — task4.S
Ввод для примера: строки "7", "-4", "8", "-1" (каждая оканчивается '\n').
Ожидаемая сумма: 7 + (-4) + 8 + (-1) = 10.

Запуск с примером:
printf "7\n-4\n8\n-1\n" | ./task4

Начальная инициализация (_start):
- sum=0 (word, 2 байта). digit_flag=0. neg_flag=0.
- В буферах заранее записан '\n': sum_str[5], oct_str[6], bin_str[16] = 10.

Цикл чтения read_loop → Getchar:
Возвращает %eax=1 при успехе и %eax=0 при EOF.
Каждый считанный байт попадает в c, затем в AL.

Строка 1: «7\n»
1) Читается '7' (код 55). AL=55. Проверка на '\n' — нет. На '-' — нет.
2) Диапазон '0'..'9' — да. Вычитаем '0': AL=7.
3) neg_flag=0 → знак не инвертируется. last_digit=7. digit_flag=1.
4) Читается '\n' (код 10). Ветка handle_newline:
   - digit_flag=1 → добавляем last_digit к sum.
   - movswl sum, %eax → AX=0. movsbl last_digit, %ecx → CX=7.
   - addw %cx, %ax → AX=7. OF=0. sum=7.
   - Сброс digit_flag=0 и neg_flag=0.

Строка 2: «-4\n»
1) Читается '-' → neg_flag=1.
2) Читается '4' (код 52). AL=52 → вычесть '0' → AL=4.
3) neg_flag=1 → negl для байта: AL=-4. neg_flag=0.
   last_digit=-4. digit_flag=1.
4) Читается '\n':
   - sum=7, CX=-4 → addw %cx,%ax → AX=3. OF=0. sum=3.
   - Сброс digit_flag=0, neg_flag=0.

Строка 3: «8\n»
1) '8' → AL=56 → AL=8. neg_flag=0.
   last_digit=8. digit_flag=1.
2) '\n': sum=3 + 8 = 11. OF=0. sum=11.
   Сброс флагов.

Строка 4: «-1\n»
1) '-' → neg_flag=1.
2) '1' → AL=49 → AL=1 → neg_flag=1 → AL=-1. neg_flag=0.
   last_digit=-1. digit_flag=1.
3) '\n': sum=11 + (-1) = 10. OF=0. sum=10.
   Сброс флагов.

EOF: Getchar возвращает EAX=0 → end_of_file.
Далее три вывода: десятичный, восьмеричный, двоичный.
Печать знака: EAX проверяется на < 0. Для 10 знак не печатается.

1) Десятичное представление (sum_str):
- Исходное значение EAX=10. EDI указывает на '\n' в sum_str.
- Цикл деления на 10. Каждый шаг: EDX=0; divl $10; остаток → '0'+EDX; запись слева от '\n'.
  Итерация 1: 10 / 10 → частное 1, остаток 0 → записать '0'.
  Итерация 2: 1 / 10 → частное 0, остаток 1 → записать '1'.
- Длина = (адрес после '\n') − (адрес первой цифры) = 3 байта («10\n»).
- write(stdout, "10\n", 3).

2) Восьмеричное представление (oct_str):
- EAX=10. Знак не печатается.
- Деление на 8.
  Итерация 1: 10 / 8 → q=1, r=2 → '2'.
  Итерация 2: 1 / 8 → q=0, r=1 → '1'.
- Получаем «12\n». write(stdout, "12\n", 3).

3) Двоичное представление (bin_str):
- EAX=10. Деление на 2.
  10/2 → q=5, r=0 → '0'
  5/2  → q=2, r=1 → '1'
  2/2  → q=1, r=0 → '0'
  1/2  → q=0, r=1 → '1'
- Получаем «1010\n». write(stdout, "1010\n", 5).

Итоговый вывод программы на примере:
10
12
1010

Замечания для защиты:
- Сумма хранится как 16-битное знаковое слово. Контроль переполнения по флагу OF после addw.
- Знак числа для печати обрабатывается отдельно: при отрицательном EAX сначала вывод «-», затем модуль и цифры.
- Для листинга использовать ключи -ahlsм=task4.lst и -gstabs+; смотреть соответствие адресов и меток.
