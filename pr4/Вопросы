"overflow_len = . - overflow_msg # на этапе ассемблирования вычисляется 
длина строки overflow_msg" Зачем это нужно?

В Linux‑системных вызовах, которые вы используете, функция `write` 
принимает три аргумента: файловый дескриптор, адрес данных и 
количество байтов, которое нужно отправить. 
Сам ассемблер не знает длину строки «Переполнение\n» — он просто 
размещает её в памяти. Поэтому мы вводим символическую константу:

overflow_len = . - overflow_msg

Здесь `.` обозначает текущую позицию ассемблера; 
вычитая адрес начала строки (`overflow_msg`), мы получаем её фактическую 
длину. Эта константа подставляется в поле `EDX` при вызове `write` — и 
тогда выводится ровно столько символов, сколько содержит сообщение. 
Если бы вы использовали макрос `Puts`, вычислять длину не требовалось бы, 
потому что макрос формирует строку сам. Но при прямом вызове `write` 
без правильного значения в `EDX` можно было бы вывести лишние байты или, 
наоборот, не вывести весь текст.

-------------------------------------------------------------------------

Что значит ".ascii" ?

Директива `.ascii` — это команда ассемблера GNU (GAS), которая помещает 
прямо в объектный файл набор байтов, соответствующих указанной строке 
в ASCII‑кодировке. Например, строка

overflow_msg:
    .ascii "Переполнение\n"

создаёт в секции `.data` последовательность байтов, равную ASCII‑кодам 
символов «П», «е», «р» … и символа перевода строки `\n`. В отличие от 
директивы `.string` (или эквивалентной `.asciz`), `.ascii` не
добавляет завершающий нулевой байт (`\0`) в конец, поэтому вы сами 
контролируете, что именно будет записано в память. Эта директива удобна 
для хранения текстовых сообщений, которые затем передаются в системный 
вызов `write`, как в нашем примере.

-------------------------------------------------------------------------

"буфер для хранения прочитанного байта из stdin" тоже самое 
что "буфер для хранения прочитанного байта из строки" ?

В нашем контексте это немного разные вещи. Переменная `c` используется 
как ячейка памяти, куда макрос `Getchar` записывает **один байт, 
прочитанный из стандартного ввода** (`stdin`), то есть из потока данных, 
которым обычно является клавиатура или перенаправлённый файл. Поэтому в 
комментарии и говорится «буфер для хранения прочитанного байта из 
stdin» — подчёркивается источник данных (файловый дескриптор 0).
Если бы мы работали со строкой, уже размещённой в памяти нашей программы, 
нам не потребовался бы системный вызов `read`: мы бы просто обращались к 
элементам этого массива. В таком случае комментарий «буфер для хранения 
прочитанного байта из строки» означал бы совсем другое — временное 
хранение символа, взятого из уже существующей строки. В данном же примере 
буфер `c` служит для приёма байтов, которые поступают из стандартного 
потока ввода.

-------------------------------------------------------------------------

".lcomm sum_str, 7 # буфер вывода: максимум 5 цифр, затем '\n', плюс 
запас под '\0' (не используется)" 
Зачем нам по итогу нужно такое условие?

Всё дело в том, чтобы заранее зарезервировать достаточно места для всех 
возможных символов, которые нужно вывести, и при этом упростить адресные 
вычисления.
Для 16‑битного беззнакового числа максимальное десятичное представление 
— «65535», то есть пять цифр. К ним мы добавляем символ перевода строки, 
чтобы после числа курсор перешёл на новую строку. Это уже шесть байтов. 
В нашем коде мы вычисляем адрес первого байта после строки 
как `sum_str+6` и используем его для расчёта длины:

leal sum_str+6, %esi   # адрес одного байта за '\n'
subl %edi, %esi        # длина = (&sum_str[6] - EDI)

Если бы буфер был размером ровно 6 байт, адрес `sum_str+6` указывал бы 
на память за пределами выделенной области, что само по себе неопасно 
в этом примере, но нарушает аккуратность и может путать. Чтобы избежать 
таких пограничных ситуаций, часто резервируют на один байт больше: это 
даёт «запас» как для безопасной адресной арифметики, так и для 
потенциального нулевого терминирующего символа (`'\0'`), если бы вы 
захотели превратить строку в C‑style.
Таким образом, `.lcomm sum_str, 7` — это просто аккуратная заготовка: пять 
цифр + перевод строки + ещё один свободный байт. В самом выводе мы 
используем только шесть символов (цифры и `\n`), а нулевой байт нам не 
нужен, потому что мы выводим строку через системный вызов `write` и 
передаём длину явно.
